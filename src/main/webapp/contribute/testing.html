---
title: Contribute | Testing
description: "Learn how to write tests for Apache Unomi, which tests are appropriate where, and when tests are run."
keywords: "Apache Unomi testing, unit tests, integration tests, Pax Exam, JUnit, Maven Surefire, CI/CD, GitHub Actions"
layout: default
---

<section class="page-header">
    <div class="container">
        <p class="section-label text-hero-label">Contribute</p>
        <h1>Apache Unomi Testing</h1>
    </div>
</section>

<section class="section">
    <div class="container">
        <div class="row g-5">
            <div class="col-lg-3">
                <div class="sidenav-menu">
                    <div class="menu-title">Contribute</div>
                    <ul class="list-unstyled mb-3">
                        <li><a href="index.html">Getting Started</a></li>
                    </ul>
                    <div class="menu-title mt-3">Technical Docs</div>
                    <ul class="list-unstyled mb-3">
                        <li><a href="testing.html" class="active">Testing Guide</a></li>
                        <li><a href="dependencies-guide.html">Dependencies Guide</a></li>
                    </ul>
                    <div class="menu-title mt-3">Policies</div>
                    <ul class="list-unstyled mb-3">
                        <li><a href="pre-commit-test-policies.html">Pre-commit Policies</a></li>
                        <li><a href="post-commit-test-policies.html">Post-commit Policies</a></li>
                    </ul>
                    <div class="menu-title mt-3">Committers</div>
                    <ul class="list-unstyled mb-0">
                        <li><a href="become-a-committer.html">Become a Committer</a></li>
                        <li><a href="committer-guide.html">Committer Guide</a></li>
                        <li><a href="release-guide.html">Release Guide</a></li>
                    </ul>
                </div>
            </div>
            <div class="col-lg-9">
            <p>This document outlines how to write tests, which tests are appropriate where, and when tests are run, with some additional information about the testing systems at the bottom.</p>

            <h3 id="testing-scenarios">Testing Scenarios</h3>

            <p>Ideally, all available tests should be run against a pull request (PR) before it's allowed to be committed to Unomi's <a target="_blank" rel="noopener" href="https://github.com/apache/unomi">Github</a> repo. This is not possible, however, due to a combination of time and resource constraints. Running all tests for each PR would take hours or even days using available resources, which would slow down development considerably.</p>

            <p>Thus tests are split into <em>pre-commit</em> and <em>post-commit</em> suites. Pre-commit is fast, while post-commit is comprehensive. As their names imply, pre-commit tests are run on each PR before it is committed, while post-commits run periodically against the master branch (i.e. on already committed PRs).</p>

            <p>Unomi uses <a target="_blank" rel="noopener" href="https://github.com/apache/unomi/actions/workflows/unomi-ci-build-tests.yml">GitHub Actions</a> to run pre-commit and post-commit tests.</p>

            <h4 id="pre-commit">Pre-commit</h4>

            <p>The pre-commit test suite verifies correctness via two testing tools: unit tests and integration tests. Unit tests ensure correctness at a basic level, while a full build (<code>mvn clean install</code>) compiles all modules and runs unit tests to verify that a basic level of functionality exists.</p>

            <p>This combination of tests hits the appropriate tradeoff between a desire for
            short (ideally &lt;30m) pre-commit times and a desire to verify that PRs going
            into Unomi function in the way in which they are intended.</p>

            <p>Pre-commit jobs are kicked off when a contributor makes a PR against the <code>apache/unomi</code> repository. Job statuses are displayed at the bottom of the PR page. Clicking on "Details" will open the status page in the selected tool; there, you can view test status and output.</p>

            <h4 id="post-commit">Post-commit</h4>

            <p>Running in post-commit removes the stringent time constraint, which gives us the ability to do more comprehensive testing. In post-commit the full integration test suite is executed against both supported search engines &mdash; <strong>Elasticsearch</strong> and <strong>OpenSearch</strong> &mdash; via the <code>-Pintegration-tests</code> Maven profile. The suite is defined in <a target="_blank" rel="noopener" href="https://github.com/apache/unomi/blob/master/itests/src/test/java/org/apache/unomi/itests/AllITs.java"><code>AllITs.java</code></a> and currently contains 30+ test classes covering profiles, segments, events, conditions, rules, privacy, import/export, GraphQL API, JSON Schema validation, health checks, and data migration scenarios.</p>

            <p>Adding new integration tests is generally as easy as adding a <code>*IT.java</code> file to the <code>itests/</code> module and registering it in the <code>AllITs.java</code> suite class. New tests should extend <a target="_blank" rel="noopener" href="https://github.com/apache/unomi/blob/master/itests/src/test/java/org/apache/unomi/itests/BaseIT.java"><code>BaseIT</code></a>, which provides access to all Unomi OSGi services, an HTTP client for REST API calls, and helper methods for waiting and retrying asynchronous operations.</p>

            <p>Post-commit test results can be found in <a target="_blank" rel="noopener" href="https://github.com/apache/unomi/actions/workflows/unomi-ci-build-tests.yml">GitHub Actions</a>.</p>

            <h3 id="testing-types">Testing Types</h3>

            <h4 id="unit">Unit</h4>

            <p>Unit tests are, in Unomi as everywhere else, the first line of defense in ensuring software correctness. As all of the contributors to Unomi understand the importance of testing, Unomi has a robust set of unit tests, as well as testing overage measurement tools, which protect the codebase from simple to moderate breakages. Unomi Java unit tests are written in JUnit.</p>

            <h4 id="how-to-run-java-needsrunner-tests">How to run Java tests</h4>

            <p>Apache Unomi uses <strong>JUnit 4</strong> for unit tests and the <strong>Maven Surefire Plugin</strong> for execution. Unit tests are located in each module&rsquo;s <code>src/test/java</code> directory and follow standard Maven conventions. To run all unit tests across the project:</p>

            <pre class="alert alert-primary"><code>$ mvn clean test</code></pre>

            <p>To run a specific test class:</p>

            <pre class="alert alert-primary"><code>$ mvn test -Dtest=MyClassTest</code></pre>

            <p>To run the full integration test suite (requires Elasticsearch or OpenSearch running):</p>

            <pre class="alert alert-primary"><code>$ mvn clean install -Pintegration-tests</code></pre>

            <p>For OpenSearch instead of Elasticsearch, add <code>-Duse.opensearch=true</code>. Integration tests use the <strong>Maven Failsafe Plugin</strong> and follow the <code>*IT.java</code> naming convention.</p>

            <h4 id="e2e">E2E</h4>

            <p>Integration tests (E2E) are meant to verify at the very highest level that the Unomi codebase is working as intended. They boot a real Apache Karaf container with Unomi deployed inside it, connected to a real search engine (Elasticsearch or OpenSearch). These tests verify that core Unomi services are fully operational end-to-end, including profile management, event collection, segmentation, rule execution, context serving, consent and privacy controls, data import/export workflows, GraphQL API operations, JSON Schema validation, and data migration between versions.</p>

            <h3 id="testing-systems">Testing Systems</h3>

            <h4 id="e2e-testing-framework">Integration Testing Framework</h4>

            <p>Unomi&rsquo;s integration tests use the following technology stack:</p>

            <ul>
                <li><strong><a target="_blank" rel="noopener" href="https://ops4j1.jira.com/wiki/spaces/PAXEXAM4/overview">Pax Exam</a></strong> &mdash; An OSGi testing framework that provisions and manages the Apache Karaf container used during tests. It handles downloading the Unomi distribution, configuring features, and injecting OSGi services into test classes.</li>
                <li><strong><a target="_blank" rel="noopener" href="https://karaf.apache.org/">Apache Karaf</a> Test Support</strong> &mdash; Provides the base class (<code>KarafTestSupport</code>) for container-based integration tests, enabling Karaf shell command execution and OSGi service lookups.</li>
                <li><strong><a target="_blank" rel="noopener" href="https://maven.apache.org/surefire/maven-failsafe-plugin/">Maven Failsafe Plugin</a></strong> &mdash; Executes the integration tests during the <code>integration-test</code> phase and verifies results in the <code>verify</code> phase. Tests follow the <code>*IT.java</code> naming convention.</li>
                <li><strong>Embedded Elasticsearch / Docker OpenSearch</strong> &mdash; The Elasticsearch profile uses the <code>elasticsearch-maven-plugin</code> to start an embedded Elasticsearch instance, while the OpenSearch profile uses the <code>docker-maven-plugin</code> to spin up an OpenSearch container.</li>
                <li><strong><a target="_blank" rel="noopener" href="https://www.jacoco.org/">JaCoCo</a></strong> &mdash; Optionally collects code coverage data during integration test runs.</li>
            </ul>

            <p>All test classes extend <a target="_blank" rel="noopener" href="https://github.com/apache/unomi/blob/master/itests/src/test/java/org/apache/unomi/itests/BaseIT.java"><code>BaseIT</code></a>, which provides access to injected Unomi services (ProfileService, RulesService, SegmentService, etc.), a pre-configured HTTP client for REST API testing, and utility methods for polling asynchronous operations.</p>

            <h4 id="ci">Continuous Integration</h4>

            <p>Unomi uses <strong>GitHub Actions</strong> for continuous integration. The <a target="_blank" rel="noopener" href="https://github.com/apache/unomi/blob/master/.github/workflows/unomi-ci-build-tests.yml"><code>unomi-ci-build-tests.yml</code></a> workflow is triggered on every push to <code>master</code> and on pull requests. It runs in two stages:</p>

            <ol>
                <li><strong>Unit tests</strong> &mdash; A full <code>mvn clean install</code> build with a 15-minute timeout. This must pass before integration tests begin.</li>
                <li><strong>Integration tests</strong> &mdash; Run in a matrix against both Elasticsearch (port 9400) and OpenSearch (port 9401) using JDK 17. Test results and logs are archived as GitHub Actions artifacts on failure.</li>
            </ol>

            <h3 id="best_practices">Best practices for writing tests</h3>

            <p>The following best practices help you to write reliable and maintainable tests.</p>

            <h4 id="aim-for-one-failure-path">Aim for one failure path</h4>

            <p>An ideal test has one failure path. When you create your tests, minimize the possible reasons for a test failure. A developer can debug a problem more easily when there are fewer failure paths.</p>

            <h4 id="avoid-non-deterministic-code">Avoid non-deterministic code</h4>

            <p>Reliable tests are predictable and deterministic. Tests that contain non-deterministic code are hard to debug and are often flaky. Non-deterministic code includes the use of randomness, time, and multithreading.</p>

            <p>To avoid non-deterministic code, mock the corresponding methods or classes.</p>

            <h4 id="use-descriptive-test-names">Use descriptive test names</h4>

            <p>Helpful test names contain details about your test, such as test parameters and the expected result. Ideally, a developer can read the test name and know where the buggy code is and how to reproduce the bug.</p>

            <p>An easy and effective way to name your methods is to use these three questions:</p>

            <ul>
              <li>What you are testing?</li>
              <li>What are the parameters of the test?</li>
              <li>What is the expected result of the test?</li>
            </ul>

            <p>For example, consider a scenario where you want to add a test for the
            <code>Divide</code> method</p>

            <p>If you use a simple test name, such as <code>testDivide()</code>, you are missing important information such as the expected action, parameter information, and expected test result. As a result, triaging a test failure requires you to look at the test implementation to see what the test does.</p>

            <p>Instead, use a name such as <code>invokingDivideWithDivisorEqualToZeroThrowsException()</code>, which specifies:</p>

            <ul>
              <li>the expected action of the test (<code>invokingDivide</code>)</li>
              <li>details about important parameters (the divisor is zero)</li>
              <li>the expected result (the test throws an exception)</li>
            </ul>

            <p>If this test fails, you can look at the descriptive test name to find the most probable cause of the failure. In addition, test frameworks and test result
            dashboards use the test name when reporting test results. Descriptive names enable contributors to look at test suite results and easily see what features are failing.</p>

            <p>Long method names are not a problem for test code. Test names are rarely used (usually when you triage and debug), and when you do need to look at a
            test, it is helpful to have descriptive names.</p>

            <h4 id="use-a-pre-commit-test-if-possible">Use a pre-commit test if possible</h4>

            <p>Post-commit tests validate that Unomi works correctly in broad variety of scenarios. The tests catch errors that are hard to predict in the design and implementation stages</p>

            <p>However, we often write a test to verify a specific scenario. In this situation, it is usually possible to implement the test as a unit test or a component test. You can add your unit tests or component tests to the pre-commit test suite, and the pre-commit test results give you faster code health feedback during the development stage, when a bug is cheap to fix.</p>
            </div>
        </div>
    </div>
</section>
